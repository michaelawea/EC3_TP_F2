# 第1部分问题解答

本文档旨在回答 `TP VHDL Temperature 2025.pdf` 中第一部分提出的问题。

## 问题 1: I2C读写命令

为了从ADT7420温度传感器读取温度值，需要执行一个复合操作。首先，我们需要告诉传感器我们想要读取哪个寄存器，然后才能从中读取数据。根据文档，温度值存放在地址为 `0x00` 和 `0x01` 的两个寄存器中。默认情况下，传感器的寄存器指针指向 `0x00`，因此我们可以直接开始读。但更通用的做法是先显式设置寄存器指针。

操作流程如下：

1.  **设置寄存器指针 (写操作):**
    *   **起始条件 (Start)**。
    *   发送I2C从设备地址和写指令：`1001011` (地址) + `0` (写) = `0x96`。
    *   等待从设备应答 (ACK)。
    *   发送要读取的寄存器地址：`00000000` (MSB Value Register)。
    *   等待从设备应答 (ACK)。

2.  **读取温度数据 (读操作):**
    *   **重复起始条件 (Repeated Start)**，以避免释放总线。
    *   发送I2C从设备地址和读指令：`1001011` (地址) + `1` (读) = `0x97`。
    *   等待从设备应答 (ACK)。
    *   从传感器读取第一个字节（高位字节 MSB），主设备在接收后发送 **ACK** 以表示还想继续读。
    *   从传感器读取第二个字节（低位字节 LSB），主设备在接收后发送 **NACK** (非应答) 以表示读取结束。
    *   **停止条件 (Stop)**。

## 问题 2: `i2c_master` 的同步信号

用于同步连续命令触发的 `i2c_master` 实体输出是 **`busy`** 信号。

当 `i2c_master` 正在执行一次传输（如发送一个字节或接收一个字节）时，`busy` 信号会置为 `'1'`。当该次传输完成，并且 `i2c_master` 准备好接收下一个指令时，`busy` 信号会短暂地变为 `'0'`。

因此，控制 `i2c_master` 的外部状态机（即 `temp_reader`）应该：
1.  设置好 `addr`, `rw`, `data_wr` 等输入。
2.  将 `ena` 置为 `'1'` 来请求一次操作。
3.  等待 `busy` 信号变为 `'0'`，这表示当前操作已完成，可以准备发起下一个操作。

## 问题 3: `ena` 信号的控制

为了确保命令可以连续发送（例如，在写操作后紧接着一个读操作）而不在中间产生停止（STOP）条件，**`ena` 信号必须在整个连续传输序列中保持为高电平 `'1'`**。

根据 `i2c_master.vhd` 的内部逻辑（`slv_ack2` 和 `mstr_ack` 状态），在完成一个字节的传输（读或写）并收到从设备的ACK后，状态机会检查 `ena` 信号：
*   如果 `ena` 为 `'1'`，状态机会根据输入 `addr` 和 `rw` 的变化判断是继续下一次读/写还是发起重复起始（Repeated Start）。它不会进入 `stop` 状态。
*   如果 `ena` 为 `'0'`，状态机则认为传输序列结束，会进入 `stop` 状态并产生一个停止条件。

因此，要实现“设置寄存器指针”后紧跟“读取数据”，`temp_reader` 必须在发起写操作和读操作期间，全程将传递给 `i2c_master` 的 `ena` 信号保持为 `'1'`。

## 问题 4 & 5: `temp_reader` 状态机设计

`temp_reader` 模块需要一个状态机来控制 `i2c_master` 模块，以完成一次完整的温度读取流程。外部 `trig` 信号触发该状态机，而 `temp_reader` 自己的 `busy` 输出则告知外部模块它是否正忙。

以下是状态机的设计描述：

*   **实体端口:**
    *   `clk`, `reset_n`: 时钟和复位。
    *   `trig`: 输入，启动一次温度读取。
    *   `busy`: 输出，表示 `temp_reader` 正在工作中。
    *   `temp_data_out`: 输出，一个16位的 `STD_LOGIC_VECTOR`，用于存储读取到的温度值。
    *   连接到 `i2c_master` 的所有端口 (`i2c_addr`, `i2c_rw`, `i2c_data_wr`, `i2c_ena` 等)。

*   **内部信号:**
    *   `state`: 状态机当前状态。
    *   `temp_data_reg`: 16位寄存器，用于拼接从I2C读取的两个字节。

*   **状态描述:**

    1.  `ST_IDLE` (空闲状态)
        *   `busy` <= `'0'`。
        *   等待 `trig` 信号变为 `'1'`。
        *   当 `trig` = `'1'` 时，`busy` <= `'1'`，跳转到 `ST_SET_POINTER`。

    2.  `ST_SET_POINTER` (设置寄存器指针)
        *   **目的:** 发送写命令，将传感器内部地址指针指向 `0x00`。
        *   **控制 `i2c_master`:**
            *   `i2c_addr` <= ` "1001011" `。
            *   `i2c_rw` <= `'0'` (写)。
            *   `i2c_data_wr` <= `x"00"` (寄存器地址)。
            *   `i2c_ena` <= `'1'`。
        *   **跳转:** 等待 `i2c_busy` 变为 `'0'`，然后跳转到 `ST_READ_MSB`。`i2c_ena` 必须保持 `'1'`。

    3.  `ST_READ_MSB` (读取高位字节)
        *   **目的:** 使用重复起始条件，发起读操作，读取温度的高位字节。
        *   **控制 `i2c_master`:**
            *   `i2c_addr` <= ` "1001011" `。
            *   `i2c_rw` <= `'1'` (读)。
            *   `i2c_ena` <= `'1'` (保持高电平以实现重复起始和连续读取)。
        *   **跳转:** 等待 `i2c_busy` 变为 `'0'`。当 `i2c_busy` 变为 `'0'` 时：
            *   将 `i2c_data_rd` 的值存入 `temp_data_reg` 的高8位: `temp_data_reg(15 downto 8) <= i2c_data_rd`。
            *   跳转到 `ST_READ_LSB`。

    4.  `ST_READ_LSB` (读取低位字节)
        *   **目的:** 接上一状态，继续读取温度的低位字节。
        *   **控制 `i2c_master`:**
            *   `i2c_addr` 和 `i2c_rw` 保持不变。
            *   **`i2c_ena` <= `'0'`**: 这是关键。将 `ena` 置低，通知 `i2c_master` 这是最后一个字节，在读取后应发送 NACK 并产生 STOP 条件。
        *   **跳转:** 等待 `i2c_busy` 变为 `'0'`。当 `i2c_busy` 变为 `'0'` 时：
            *   将 `i2c_data_rd` 的值存入 `temp_data_reg` 的低8位: `temp_data_reg(7 downto 0) <= i2c_data_rd`。
            *   跳转到 `ST_DONE`。

    5.  `ST_DONE` (完成状态)
        *   **目的:** 结束本次读取流程。
        *   **操作:**
            *   `temp_data_out` <= `temp_data_reg` (将最终结果输出)。
            *   等待 `i2c_busy` 变为 `'0'` (确保 `i2c_master` 已完成 STOP 操作并进入 ready 状态)。
        *   **跳转:** 跳转回 `ST_IDLE`。
