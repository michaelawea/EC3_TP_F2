# Testbench问题分析：为什么busy只上升一次

## 问题描述
在仿真temp_reader时，发现busy信号只上升了一次，第二次触发trig信号后busy没有反应。

## 原因分析

### 1. I2C模拟进程的问题
在`tb_temp_reader.vhd`的`i2c_sim`进程中：

```vhdl
i2c_sim : process
begin
    i2c_busy <= '0';
    data_rd <= (others => '0');

    -- 第一次：写寄存器地址
    wait until i2c_ena = '1' and i2c_rw = '0';
    ...

    -- 第二次：读MSB
    wait until i2c_ena = '1' and i2c_rw = '1';
    ...

    -- 第三次：读LSB
    wait until i2c_ena = '1' and i2c_rw = '1';
    ...

    wait;  -- ← 这里永远等待，进程结束
end process;
```

**关键问题**：进程最后的`wait;`语句使得整个进程永远停止，不会再响应新的I2C传输请求。

### 2. 执行流程

#### 第一次读取（成功）：
1. `trig = '1'` → 状态机启动
2. `busy = '1'` → 开始工作
3. `i2c_ena = '1'` → I2C模拟进程响应
4. `i2c_busy: 0→1→0`（写地址）
5. `i2c_busy: 0→1→0`（读MSB）
6. `i2c_busy: 0→1→0`（读LSB）
7. `busy = '0'` → 回到idle

#### 第二次读取（失败）：
1. `trig = '1'` → 状态机再次启动
2. 状态机进入`wr_reg_address`状态
3. `i2c_ena = '1'`, `i2c_rw = '0'`
4. **但是**：i2c_sim进程已经在`wait;`永远等待
5. `i2c_busy`永远保持在`'0'`
6. 状态机在`wr_reg_address`等待`i2c_busy = '1'`，**永远卡住**
7. `busy`信号保持在`'1'`，**无法完成第二次读取**

### 3. 状态转移卡死点

```vhdl
-- 在NEXT_STATE_DECODE进程中
when wr_reg_address =>
    if i2c_busy = '1' then        -- ← 永远等待这个条件
        next_state <= st_busy_1;
    end if;
```

因为i2c_sim进程不再响应，`i2c_busy`永远是`'0'`，状态机卡在`wr_reg_address`状态。

## 解决方案

### 方案1：去掉第二次测试
最简单的方法，只测试一次读取即可。

### 方案2：修改i2c_sim进程为循环结构
```vhdl
i2c_sim : process
begin
    i2c_busy <= '0';
    data_rd <= (others => '0');

    loop  -- 添加循环
        -- 写寄存器地址
        wait until i2c_ena = '1' and i2c_rw = '0';
        wait for 3 * TbPeriod;
        i2c_busy <= '1';
        wait for 10 * TbPeriod;
        i2c_busy <= '0';
        wait for 2 * TbPeriod;

        -- 读MSB
        wait until i2c_ena = '1' and i2c_rw = '1';
        wait for 3 * TbPeriod;
        i2c_busy <= '1';
        wait for 10 * TbPeriod;
        data_rd <= TEMP_MSB;
        wait for 1 * TbPeriod;
        i2c_busy <= '0';
        wait for 2 * TbPeriod;

        -- 读LSB
        wait until i2c_ena = '1' and i2c_rw = '1';
        wait for 3 * TbPeriod;
        i2c_busy <= '1';
        wait for 10 * TbPeriod;
        data_rd <= TEMP_LSB;
        wait for 1 * TbPeriod;
        i2c_busy <= '0';

        -- 循环继续，可以响应下一次请求
    end loop;
end process;
```

### 方案3：使用单独的响应逻辑
用更通用的方式响应所有I2C请求，而不是顺序执行。

## 总结

**busy只上升一次的根本原因**：
- I2C模拟进程执行完一次完整流程后永远停止（`wait;`）
- 第二次触发时，状态机启动但i2c_busy无人驱动
- 状态机卡在等待`i2c_busy = '1'`的状态
- `busy`信号保持高电平无法返回

**推荐做法**：
如果只需要测试一次读取功能，保持当前设计；如果需要多次测试，将i2c_sim进程改为循环结构。

---

# 第二个问题：i2c_busy一直为0的分析

## 问题描述
在仿真过程中观察到以下现象（见波形图）：

![仿真波形图](截图显示的波形)

### 波形分析（时间：0.994375 us）：
```
clk         : 正常时钟信号
rst         : 0 (未复位)
trig        : 0
data_rd[7:0]: 00
i2c_busy    : 0  ← 问题：一直为0
i2c_ack     : 0
busy        : 0
data[15:0]  : 0000
i2c_ena     : 1  ← 状态机已发出使能
i2c_rw      : 1  ← 读操作
i2c_data_wr : 00
i2c_addr    : 4b ← 正确的传感器地址
TEMP_MSB    : 0c
TEMP_LSB    : 88
```

**关键问题**：
- 状态机已经发出读请求：`i2c_ena = 1`, `i2c_rw = 1`
- 但testbench的i2c模拟没有响应：`i2c_busy = 0`（应该变成1）
- 导致状态机卡住，无法继续

## 原因分析

### 1. Testbench的等待顺序问题

Testbench的i2c_sim进程按照固定顺序等待：

```vhdl
i2c_sim : process
begin
    i2c_busy <= '0';
    data_rd <= (others => '0');

    -- 第1步：等待写操作
    wait until i2c_ena = '1' and i2c_rw = '0';  -- 写寄存器地址
    wait for 3 * TbPeriod;
    i2c_busy <= '1';
    wait for 10 * TbPeriod;
    i2c_busy <= '0';
    wait for 2 * TbPeriod;

    -- 第2步：等待读操作
    wait until i2c_ena = '1' and i2c_rw = '1';  -- 读MSB
    ...

    -- 第3步：等待读操作
    wait until i2c_ena = '1' and i2c_rw = '1';  -- 读LSB
    ...

    wait;  -- 永远等待
end process;
```

### 2. 状态机的转移流程

```vhdl
idle → (trig=1) → wr_reg_address → (i2c_busy=1) → st_busy_1
    → (i2c_busy=0) → st_busy_0_1 → read_temp_MSB → ...
```

在`st_busy_0_1`状态：
```vhdl
when st_busy_0_1 =>
    busy <= '1';
    i2c_ena <= '1';
    i2c_rw <= '1';  -- ← i2c_rw变成1（读操作）

-- 转移逻辑
when st_busy_0_1 =>
    next_state <= read_temp_MSB;  -- 无条件转移
```

### 3. 问题发生的时序

#### 正常情况应该是：
1. **写操作阶段**：
   - 状态机：`wr_reg_address` → `i2c_ena=1, i2c_rw=0`
   - Testbench：检测到，设置`i2c_busy: 0→1→0`
   - 状态机：`st_busy_1` → `st_busy_0_1`

2. **读MSB阶段**：
   - 状态机：`st_busy_0_1` → `i2c_ena=1, i2c_rw=1`
   - Testbench：应该检测到并响应
   - **但实际：testbench没有响应，i2c_busy保持为0**

#### 可能的原因：

**时序失配问题**：

当testbench完成写操作的模拟后：
```vhdl
i2c_busy <= '0';
wait for 2 * TbPeriod;  -- ← 在这20ns内

-- 然后执行
wait until i2c_ena = '1' and i2c_rw = '1';  -- ← 到达这里时
```

在这20ns的延迟期间，状态机已经从`st_busy_1`转到`st_busy_0_1`，此时：
- `i2c_ena = 1`
- `i2c_rw = 1`（已经变成读操作）

当testbench执行到第二个`wait until`时，条件**已经满足**（在st_busy_0_1状态），testbench应该**立即通过**这个wait语句，继续执行后续代码。

**但是**，从波形看testbench没有响应，说明可能：

1. **Testbench的进程被卡住**：
   - 可能在之前的`wait for`语句中
   - 或者信号更新有延迟

2. **信号采样问题**：
   - `wait until`语句在特定的delta时间检测信号
   - 如果在`wait for`结束和`wait until`开始之间，信号变化太快
   - 可能会错过关键的信号变化

3. **状态机转移太快**：
   - `st_busy_0_1`是无条件转移到`read_temp_MSB`
   - 在testbench的`wait for 2 * TbPeriod`期间，状态机可能已经转移了多个状态
   - 导致testbench错过了某个关键的信号变化窗口

### 4. 波形中的状态推断

从波形信号看：
- `i2c_ena = 1`
- `i2c_rw = 1`
- `i2c_busy = 0`

对应的可能状态：
- `st_busy_0_1`：i2c_ena=1, i2c_rw=1（无条件转移）
- `read_temp_MSB`：i2c_ena=1, i2c_rw=1（等待i2c_busy=1）
- `st_busy_2`：i2c_ena=1, i2c_rw=1（等待i2c_busy=0）
- `st_busy_0_2`：i2c_ena=1, i2c_rw=1

最可能是状态机在`read_temp_MSB`状态，等待testbench设置`i2c_busy=1`。

## 解决方案

### 方案1：减少testbench的延迟
```vhdl
-- 写操作后立即准备响应读操作
i2c_busy <= '0';
wait for 1 * TbPeriod;  -- 减少延迟

-- 立即等待下一个请求
wait until i2c_ena = '1' and i2c_rw = '1';
```

### 方案2：使用更鲁棒的响应逻辑
改用事件驱动的方式，而不是顺序等待：

```vhdl
i2c_sim : process
begin
    i2c_busy <= '0';
    data_rd <= (others => '0');

    loop
        -- 等待任何i2c请求
        wait until i2c_ena = '1';

        if i2c_rw = '0' then
            -- 写操作
            wait for 3 * TbPeriod;
            i2c_busy <= '1';
            wait for 10 * TbPeriod;
            i2c_busy <= '0';
        else
            -- 读操作
            wait for 3 * TbPeriod;
            i2c_busy <= '1';
            wait for 10 * TbPeriod;
            -- 提供数据（可以根据需要提供不同数据）
            if data_rd = (data_rd'range => '0') then
                data_rd <= TEMP_MSB;
            else
                data_rd <= TEMP_LSB;
            end if;
            i2c_busy <= '0';
        end if;

        wait for 2 * TbPeriod;
    end loop;
end process;
```

### 方案3：简化状态机逻辑
检查状态机的`st_busy_0_1`状态是否必要，考虑合并某些状态以减少快速转移。

## 总结

**i2c_busy一直为0的根本原因**：
- Testbench使用顺序等待的方式模拟I2C Master
- 在完成写操作后的延迟期间，状态机快速转移到读状态
- Testbench的`wait until`检测时可能错过或未正确响应状态变化
- 导致testbench卡在某个等待状态，不再驱动i2c_busy信号

**推荐解决方案**：
- 采用**方案2**的循环事件驱动方式，更加鲁棒
- 或者简化testbench，去掉不必要的延迟
- 添加调试输出，观察testbench的执行状态
