# Testbench问题分析：为什么busy只上升一次

## 问题描述
在仿真temp_reader时，发现busy信号只上升了一次，第二次触发trig信号后busy没有反应。

## 原因分析

### 1. I2C模拟进程的问题
在`tb_temp_reader.vhd`的`i2c_sim`进程中：

```vhdl
i2c_sim : process
begin
    i2c_busy <= '0';
    data_rd <= (others => '0');

    -- 第一次：写寄存器地址
    wait until i2c_ena = '1' and i2c_rw = '0';
    ...

    -- 第二次：读MSB
    wait until i2c_ena = '1' and i2c_rw = '1';
    ...

    -- 第三次：读LSB
    wait until i2c_ena = '1' and i2c_rw = '1';
    ...

    wait;  -- ← 这里永远等待，进程结束
end process;
```

**关键问题**：进程最后的`wait;`语句使得整个进程永远停止，不会再响应新的I2C传输请求。

### 2. 执行流程

#### 第一次读取（成功）：
1. `trig = '1'` → 状态机启动
2. `busy = '1'` → 开始工作
3. `i2c_ena = '1'` → I2C模拟进程响应
4. `i2c_busy: 0→1→0`（写地址）
5. `i2c_busy: 0→1→0`（读MSB）
6. `i2c_busy: 0→1→0`（读LSB）
7. `busy = '0'` → 回到idle

#### 第二次读取（失败）：
1. `trig = '1'` → 状态机再次启动
2. 状态机进入`wr_reg_address`状态
3. `i2c_ena = '1'`, `i2c_rw = '0'`
4. **但是**：i2c_sim进程已经在`wait;`永远等待
5. `i2c_busy`永远保持在`'0'`
6. 状态机在`wr_reg_address`等待`i2c_busy = '1'`，**永远卡住**
7. `busy`信号保持在`'1'`，**无法完成第二次读取**

### 3. 状态转移卡死点

```vhdl
-- 在NEXT_STATE_DECODE进程中
when wr_reg_address =>
    if i2c_busy = '1' then        -- ← 永远等待这个条件
        next_state <= st_busy_1;
    end if;
```

因为i2c_sim进程不再响应，`i2c_busy`永远是`'0'`，状态机卡在`wr_reg_address`状态。

## 解决方案

### 方案1：去掉第二次测试
最简单的方法，只测试一次读取即可。

### 方案2：修改i2c_sim进程为循环结构
```vhdl
i2c_sim : process
begin
    i2c_busy <= '0';
    data_rd <= (others => '0');

    loop  -- 添加循环
        -- 写寄存器地址
        wait until i2c_ena = '1' and i2c_rw = '0';
        wait for 3 * TbPeriod;
        i2c_busy <= '1';
        wait for 10 * TbPeriod;
        i2c_busy <= '0';
        wait for 2 * TbPeriod;

        -- 读MSB
        wait until i2c_ena = '1' and i2c_rw = '1';
        wait for 3 * TbPeriod;
        i2c_busy <= '1';
        wait for 10 * TbPeriod;
        data_rd <= TEMP_MSB;
        wait for 1 * TbPeriod;
        i2c_busy <= '0';
        wait for 2 * TbPeriod;

        -- 读LSB
        wait until i2c_ena = '1' and i2c_rw = '1';
        wait for 3 * TbPeriod;
        i2c_busy <= '1';
        wait for 10 * TbPeriod;
        data_rd <= TEMP_LSB;
        wait for 1 * TbPeriod;
        i2c_busy <= '0';

        -- 循环继续，可以响应下一次请求
    end loop;
end process;
```

### 方案3：使用单独的响应逻辑
用更通用的方式响应所有I2C请求，而不是顺序执行。

## 总结

**busy只上升一次的根本原因**：
- I2C模拟进程执行完一次完整流程后永远停止（`wait;`）
- 第二次触发时，状态机启动但i2c_busy无人驱动
- 状态机卡在等待`i2c_busy = '1'`的状态
- `busy`信号保持高电平无法返回

**推荐做法**：
如果只需要测试一次读取功能，保持当前设计；如果需要多次测试，将i2c_sim进程改为循环结构。
